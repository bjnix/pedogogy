attr);
  return self;
}

static VALUE sp_get_flow_control(self)
  VALUE self;
{
  int ret;
  int fd;
  struct termios params;

  fd = sp_get_fd(self);
  if (tcgetattr(fd, &params) == -1)
    rb_sys_fail(sTcgetattr);

  ret = 0;
#ifdef HAVE_FLOWCONTROL_HARD
  if (params.c_cflag & CRTSCTS)
    ret += HARD;
#endif
  if (params.c_iflag & (IXON | IXOFF | IXANY))
    ret += SOFT;

  return INT2FIX(ret);
}

static VALUE sp_set_input_type(self, val)
  VALUE self, val;
{
  int fd;
  int type;
  struct termios params;

  Check_Type(val, T_FIXNUM);

  fd = sp_get_fd(self);
  if (tcgetattr(fd, &params) == -1)
    rb_sys_fail(sTcgetattr);

  type = FIX2INT(val);
  if (type == PROCESSED)
    params.c_lflag |= ICANON;
  else
    params.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);

  if (tcsetattr(fd, TCSANOW, &params) == -1)
    rb_sys_fail(sTcsetattr);

  return self;
}

static VALUE sp_get_input_type(self)
  VALUE self;
{
  int ret;
  int fd;
  struct termios params;

  fd = sp_get_fd(self);
  if (tcgetattr(fd, &params) == -1)
    rb_sys_fail(sTcgetattr);

  ret = 0;
  if (params.c_lflag & ICANON)
    ret = PROCESSED;
  else
    ret = RAW;

  return INT2FIX(ret);
}

static VALUE sp_set_output_type(self, val)
  VALUE self, val;
{
  int fd;
  int type;
  struct termios params;

  Check_Type(val, T_FIXNUM);

  fd = sp_get_fd(self);
  if (tcgetattr(fd, &params) == -1)
    rb_sys_fail(sTcgetattr);

  type = FIX2INT(val);
  if (type == PROCESSED)
    params.c_oflag |= OPOST;
  else
    params.c_oflag &= ~OPOST;

  if (tcsetattr(fd, TCSANOW, &params) == -1)
    rb_sys_fail(sTcsetattr);

  return self;
}

static VALUE sp_get_output_type(self)
  VALUE self;
{
  int ret;
  int fd;
  struct termios params;

  fd = sp_get_fd(self);
  if (tcgetattr(fd, &params) == -1)
    rb_sys_fail(sTcgetattr);

  ret = 0;
  if (params.c_oflag & OPOST)
    ret = PROCESSED;
  else
    ret = RAW;

  return INT2FIX(ret);
}

static VALUE sp_set_nonblock(self, val)
  VALUE self, val;
{
  int fd;
  int flags;

  fd = sp_get_fd(self);

  flags = fcntl(fd, F_GETFL, 0);
  if(flags == -1)
    rb_sys_fail(sFcntl);

  if (val == Qtrue) {
    if(fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1)
      rb_sys_fail(sFcntl);
  }
  else if (val == Qfalse) {
    if(fcntl(fd, F_SETFL, flags & ~O_NONBLOCK) == -1)
      rb_sys_fail(sFcntl);
  }
  else
    rb_raise(rb_eArgError, "invalid value");

  return self;
}

static VALUE sp_get_nonblock(self)
  VALUE self;
{
  int fd;
  int flags;

  fd = sp_get_fd(self);
  flags = fcntl(fd, F_GETFL, 0);
  if(flags == -1)
    rb_sys_fail(sFcntl);

  return (flags & O_NONBLOCK) ? Qtrue : Qfalse;
}

static VALUE sp_set_read_timeout(self, val)
  VALUE self, val;
{
  int timeout;
  int fd;
  struct termios params;

  Check_Type(val, T_FIXNUM);
  timeout = FIX2INT(val);

  fd = sp_get_fd(self);
  if (tcgetattr(fd, &params) == -1)
    rb_sys_fail(sTcgetattr);

  if (timeout < 0) {
    params.c_cc[VTIME] = 0;
    params.c_cc[VMIN] = 0;
  } else if (timeout == 0) {
    params.c_cc[VTIME] = 0;
    params.c_cc[VMIN] = 1;
  } else {
    params.c_cc[VTIME] = (timeout + 50) / 100;
    params.c_cc[VMIN] = 0;
  }

  if (tcsetattr(fd, TCSANOW, &params) == -1)
    rb_sys_fail(sTcsetattr);
  return self;
}

static VALUE sp_get_read_timeout(self)
  VALUE self;
{
  int fd;
  struct termios params;

  fd = sp_get_fd(self);
  if (tcgetattr(fd, &params) == -1)
    rb_sys_fail(sTcgetattr);
  if (params.c_cc[VTIME] == 0 && params.c_cc[VMIN] == 0)
    return INT2FIX(-1);
  return INT2FIX(params.c_cc[VTIME] * 100);
}

static VALUE sp_set_write_timeout(self, val)
  VALUE self, val;
{
  rb_notimplement();
  return self;
}

static VALUE sp_get_write_timeout(self)
  VALUE self;
{
  rb_notimplement();
  return self;
}

static VALUE sp_break(self, time)
  VALUE self, time;
{
  int fd;

  Check_Type(time, T_FIXNUM);

  fd = sp_get_fd(self);
  if (tcsendbreak(fd, FIX2INT(time) / 3) == -1)
    rb_sys_fail("tcsendbreak");
  return Qnil;
}

static void get_line_signals(obj, ls)
  VALUE obj;
  struct line_signals *ls;
{
  int fd, status;

  fd = sp_get_fd(obj);
  if (ioctl(fd, TIOCMGET, &status) == -1)
    rb_sys_fail(sIoctl);

  ls->rts = (status & TIOCM_RTS ? 1 : 0);
  ls->dtr = (status & TIOCM_DTR ? 1 : 0);
  ls->cts = (status & TIOCM_CTS ? 1 : 0);
  ls->dsr = (status & TIOCM_DSR ? 1 : 0);
  ls->dcd = (status & TIOCM_CD ? 1 : 0);
  ls->ri = (status & TIOCM_RI ? 1 : 0);
}

static VALUE set_signal(obj, val, sig)
  VALUE obj,val;
  int sig;
{
  int status;
  int fd;
  int set;

  Check_Type(val, T_FIXNUM);
  fd = sp_get_fd(obj);
  if (ioctl(fd, TIOCMGET, &status) == -1)
    rb_sys_fail(sIoctl);

  set = FIX2INT(val);
  if (set == 0)
    status &= ~sig;
  else if (set == 1)
    status |= sig;
  else
    rb_raise(rb_eArgError, "invalid value");

  if (ioctl(fd, TIOCMSET, &status) == -1)
    rb_sys_fail(sIoctl);
  return obj;
}

static VALUE sp_set_rts(self, val)
  VALUE self, val;
{
    return set_signal(self, val, TIOCM_RTS);
}

static VALUE sp_set_dtr(self, val)
  VALUE self, val;
{
  return set_signal(self, val, TIOCM_DTR);
}

static VALUE sp_get_rts(self)
  VALUE self;
{
  struct line_signals ls;

  get_line_signals(self, &ls);
  return INT2FIX(ls.rts);
}

static VALUE sp_get_dtr(self)
  VALUE self;
{
  struct line_signals ls;

  get_line_signals(self, &ls);
  return INT2FIX(ls.dtr);
}


#endif /* defined(mswin) || defined(bccwin) */


static VALUE sp_set_data_rate(self, data_rate)
  VALUE self, data_rate;
{
  VALUE argv[4];

  argv[0] = data_rate;
  argv[1] = argv[2] = argv[3] = Qnil;
  return sp_set_modem_params(4, argv, self);
}

static VALUE sp_set_data_bits(self, data_bits)
  VALUE self, data_bits;
{
  VALUE argv[4];

  argv[1] = data_bits;
  argv[0] = argv[2] = argv[3] = Qnil;
  return sp_set_modem_params(4, argv, self);
}

static VALUE sp_set_stop_bits(self, stop_bits)
  VALUE self, stop_bits;
{
  VALUE argv[4];

  argv[2] = stop_bits;
  argv[0] = argv[1] = argv[3] = Qnil;
  return sp_set_modem_params(4, argv, self);
}

static VALUE sp_set_parity(self, parity)
  VALUE self, parity;
{
  VALUE argv[4];

  argv[3] = parity;
  argv[0] = argv[1] = argv[2] = Qnil;
  return sp_set_modem_params(4, argv, self);
}

static VALUE sp_get_data_rate(self)
  VALUE self;
{
  struct modem_params mp;

  get_modem_params(self, &mp);
  return INT2FIX(mp.data_rate);
}

static VALUE sp_get_data_bits(self)
  VALUE self;
{
  struct modem_params mp;

  get_modem_params(self, &mp);
  return INT2FIX(mp.data_bits);
}

static VALUE sp_get_stop_bits(self)
  VALUE self;
{
  struct modem_params mp;

  get_modem_params(self, &mp);
  return INT2FIX(mp.stop_bits);
}

static VALUE sp_get_parity(self)
  VALUE self;
{
  struct modem_params mp;

  get_modem_params(self, &mp);
  return INT2FIX(mp.parity);
}

static VALUE sp_get_modem_params(self)
  VALUE self;
{
  struct modem_params mp;
  VALUE hash;

  get_modem_params(self, &mp);
  hash = rb_hash_new();
  rb_hash_aset(hash, sBaud, INT2FIX(mp.data_rate));
  rb_hash_aset(hash, sDataBits, INT2FIX(mp.data_bits));
  rb_hash_aset(hash, sStopBits, INT2FIX(mp.stop_bits));
  rb_hash_aset(hash, sParity, INT2FIX(mp.parity));
  return hash;
}

static VALUE sp_get_cts(self)
  VALUE self;
{
  struct line_signals ls;

  get_line_signals(self, &ls);
  return INT2FIX(ls.cts);
}

static VALUE sp_get_dsr(self)
  VALUE self;
{
  struct line_signals ls;

  get_line_signals(self, &ls);
  return INT2FIX(ls.dsr);
}

static VALUE sp_get_dcd(self)
  VALUE self;
{
  struct line_signals ls;

  get_line_signals(self, &ls);
  return INT2FIX(ls.dcd);
}

static VALUE sp_get_ri(self)
  VALUE self;
{
  struct line_signals ls;

  get_line_signals(self, &ls);
  return INT2FIX(ls.ri);
}

static VALUE
sp_signals(self)
  VALUE self;
{
  struct line_signals ls;
  VALUE hash;

  get_line_signals(self, &ls);
  hash = rb_hash_new();
#if !(defined(mswin) || defined(bccwin))
  rb_hash_aset(hash, sRts, INT2FIX(ls.rts));
  rb_hash_aset(hash, sDtr, INT2FIX(ls.dtr));
#endif
  rb_hash_aset(hash, sCts, INT2FIX(ls.cts));
  rb_hash_aset(hash, sDsr, INT2FIX(ls.dsr));
  rb_hash_aset(hash, sDcd, INT2FIX(ls.dcd));
  rb_hash_aset(hash, sRi, INT2FIX(ls.ri));
  return hash;
}

void Init_serialport() {
  sBaud = rb_str_new2("baud");
  sDataBits = rb_str_new2("data_bits");
  sStopBits = rb_str_new2("stop_bits");
  sParity = rb_str_new2("parity");
  sRts = rb_str_new2("rts");
  sDtr = rb_str_new2("dtr");
  sCts = rb_str_new2("cts");
  sDsr = rb_str_new2("dsr");
  sDcd = rb_str_new2("dcd");
  sRi = rb_str_new2("ri");

  rb_gc_register_address(&sBaud);
  rb_gc_register_address(&sDataBits);
  rb_gc_register_address(&sStopBits);
  rb_gc_register_address(&sParity);
  rb_gc_register_address(&sRts);
  rb_gc_register_address(&sDtr);
  rb_gc_register_address(&sCts);
  rb_gc_register_address(&sDsr);
  rb_gc_register_address(&sDcd);
  rb_gc_register_address(&sRi);

  cSerialPort = rb_define_class("SerialPort", rb_cIO);
  rb_define_singleton_method(cSerialPort, "create", sp_create, 1);

  rb_define_method(cSerialPort, "get_modem_params", sp_get_modem_params, 0);
  rb_define_method(cSerialPort, "set_modem_params", sp_set_modem_params, -1);
  rb_define_method(cSerialPort, "modem_params", sp_get_modem_params, 0);
  rb_define_method(cSerialPort, "modem_params=", sp_set_modem_params, -1);
  rb_define_method(cSerialPort, "baud", sp_get_data_rate, 0);
  rb_define_method(cSerialPort, "baud=", sp_set_data_rate, 1);
  rb_define_method(cSerialPort, "data_bits", sp_get_data_bits, 0);
  rb_define_method(cSerialPort, "data_bits=", sp_set_data_bits, 1);
  rb_define_method(cSerialPort, "stop_bits", sp_get_stop_bits, 0);
  rb_define_method(cSerialPort, "stop_bits=", sp_set_stop_bits, 1);
  rb_define_method(cSerialPort, "parity", sp_get_parity, 0);
  rb_define_method(cSerialPort, "parity=", sp_set_parity, 1);

  rb_define_method(cSerialPort, "flow_control=", sp_set_flow_control, 1);
  rb_define_method(cSerialPort, "flow_control", sp_get_flow_control, 0);
  rb_define_method(cSerialPort, "input_type=", sp_set_input_type, 1);
  rb_define_method(cSerialPort, "input_type", sp_get_input_type, 0);
  rb_define_method(cSerialPort, "output_type=", sp_set_output_type, 1);
  rb_define_method(cSerialPort, "output_type", sp_get_output_type, 0);

  rb_define_method(cSerialPort, "nonblock=", sp_set_nonblock, 1);
  rb_define_method(cSerialPort, "nonblock", sp_get_nonblock, 0);

  rb_define_method(cSerialPort, "read_timeout", sp_get_read_timeout, 0);
  rb_define_method(cSerialPort, "read_timeout=", sp_set_read_timeout, 1);
  rb_define_method(cSerialPort, "write_timeout", sp_get_write_timeout, 0);
  rb_define_method(cSerialPort, "write_timeout=", sp_set_write_timeout, 1);

  rb_define_method(cSerialPort, "break", sp_break, 1);

  rb_define_method(cSerialPort, "signals", sp_signals, 0);
  rb_define_method(cSerialPort, "get_signals", sp_signals, 0);
  rb_define_method(cSerialPort, "rts", sp_get_rts, 0);
  rb_define_method(cSerialPort, "rts=", sp_set_rts, 1);
  rb_define_method(cSerialPort, "dtr", sp_get_dtr, 0);
  rb_define_method(cSerialPort, "dtr=", sp_set_dtr, 1);
  rb_define_method(cSerialPort, "cts", sp_get_cts, 0);
  rb_define_method(cSerialPort, "dsr", sp_get_dsr, 0);
  rb_define_method(cSerialPort, "dcd", sp_get_dcd, 0);
  rb_define_method(cSerialPort, "ri", sp_get_ri, 0);

  rb_define_const(cSerialPort, "NONE", INT2FIX(NONE));
  rb_define_const(cSerialPort, "HARD", INT2FIX(HARD));
  rb_define_const(cSerialPort, "SOFT", INT2FIX(SOFT));

  rb_define_const(cSerialPort, "SPACE", INT2FIX(SPACE));
  rb_define_const(cSerialPort, "MARK", INT2FIX(MARK));
  rb_define_const(cSerialPort, "EVEN", INT2FIX(EVEN));
  rb_define_const(cSerialPort, "ODD", INT2FIX(ODD));

  rb_define_const(cSerialPort, "PROCESSED", INT2FIX(PROCESSED));
  rb_define_const(cSerialPort, "RAW", INT2FIX(RAW));

  rb_define_const(cSerialPort, "VERSION", rb_str_new2(VERSION));

  /* The following definitions are more easily carried out in Ruby */
  rb_eval_string(
	"class SerialPort\n"

	  "def self.new(port, *params)\n"
	    "sp = create(port)\n"
	    "begin\n"
	      "sp.set_modem_params(*params)\n"
	    "rescue\n"
	      "sp.close\n"
	      "raise\n"
	    "end\n"
	    "return sp\n"
	  "end\n"

	  "def self.open(port, *params)\n"
	    "sp = create(port)\n"
	    "begin\n"
	      "sp.set_modem_params(*params)\n"
	      "if (block_given?)\n"
		"yield sp\n"
		"sp.close\n"
		"return nil\n"
	      "end\n"
	    "rescue\n"
	      "sp.close\n"
	      "raise\n"
	    "end\n"
	    "return sp\n"
	  "end\n"

	"end\n"
  );
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * MessagePack unpacking routine template
 *
 * Copyright (C) 2008-2010 FURUHASHI Sadayuki
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
#ifndef MSGPACK_PACK_DEFINE_H__
#define MSGPACK_PACK_DEFINE_H__

#include "msgpack/sysdep.h"
#include <limits.h>
#include <string.h>

#endif /* msgpack/pack_define.h */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * MessagePack packing routine template
 *
 * Copyright (C) 2008-2010 FURUHASHI Sadayuki
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

#if defined(__LITTLE_ENDIAN__)
#define TAKE8_8(d)  ((uint8_t*)&d)[0]
#define TAKE8_16(d) ((uint8_t*)&d)[0]
#define TAKE8_32(d) ((uint8_t*)&d)[0]
#define TAKE8_64(d) ((uint8_t*)&d)[0]
#elif defined(__BIG_ENDIAN__)
#define TAKE8_8(d)  ((uint8_t*)&d)[0]
#define TAKE8_16(d) ((uint8_t*)&d)[1]
#define TAKE8_32(d) ((uint8_t*)&d)[3]
#define TAKE8_64(d) ((uint8_t*)&d)[7]
#endif

#ifndef msgpack_pack_inline_func
#error msgpack_pack_inline_func template is not defined
#endif

#ifndef msgpack_pack_user
#error msgpack_pack_user type is not defined
#endif

#ifndef msgpack_pack_append_buffer
#error msgpack_pack_append_buffer callback is not defined
#endif


/*
 * Integer
 */

#define msgpack_pack_real_uint8(x, d) \
do { \
	if(d < (1<<7)) { \
		/* fixnum */ \
		msgpack_pack_append_buffer(x, &TAKE8_8(d), 1); \
	} else { \
		/* unsigned 8 */ \
		unsigned char buf[2] = {0xcc, TAKE8_8(d)}; \
		msgpack_pack_append_buffer(x, buf, 2); \
	} \
} while(0)

#define msgpack_pack_real_uint16(x, d) \
do { \
	if(d < (1<<7)) { \
		/* fixnum */ \
		msgpack_pack_append_buffer(x, &TAKE8_16(d), 1); \
	} else if(d < (1<<8)) { \
		/* unsigned 8 */ \
		unsigned char buf[2] = {0xcc, TAKE8_16(d)}; \
		msgpack_pack_append_buffer(x, buf, 2); \
	} else { \
		/* unsigned 16 */ \
		unsigned char buf[3]; \
		buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
		msgpack_pack_append_buffer(x, buf, 3); \
	} \
} while(0)

#define msgpack_pack_real_uint32(x, d) \
do { \
	if(d < (1<<8)) { \
		if(d < (1<<7)) { \
			/* fixnum */ \
			msgpack_pack_append_buffer(x, &TAKE8_32(d), 1); \
		} else { \
			/* unsigned 8 */ \
			unsigned char buf[2] = {0xcc, TAKE8_32(d)}; \
			msgpack_pack_append_buffer(x, buf, 2); \
		} \
	} else { \
		if(d < (1<<16)) { \
			/* unsigned 16 */ \
			unsigned char buf[3]; \
			buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
			msgpack_pack_append_buffer(x, buf, 3); \
		} else { \
			/* unsigned 32 */ \
			unsigned char buf[5]; \
			buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
			msgpack_pack_append_buffer(x, buf, 5); \
		} \
	} \
} while(0)

#define msgpack_pack_real_uint64(x, d) \
do { \
	if(d < (1ULL<<8)) { \
		if(d < (1ULL<<7)) { \
			/* fixnum */ \
			msgpack_pack_append_buffer(x, &TAKE8_64(d), 1); \
		} else { \
			/* unsigned 8 */ \
			unsigned char buf[2] = {0xcc, TAKE8_64(d)}; \
			msgpack_pack_append_buffer(x, buf, 2); \
		} \
	} else { \
		if(d < (1ULL<<16)) { \
			/* unsigned 16 */ \
			unsigned char buf[3]; \
			buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
			msgpack_pack_append_buffer(x, buf, 3); \
		} else if(d < (1ULL<<32)) { \
			/* unsigned 32 */ \
			unsigned char buf[5]; \
			buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
			msgpack_pack_append_buffer(x, buf, 5); \
		} else { \
			/* unsigned 64 */ \
			unsigned char buf[9]; \
			buf[0] = 0xcf; _msgpack_store64(&buf[1], d); \
			msgpack_pack_append_buffer(x, buf, 9); \
		} \
	} \
} while(0)

#define msgpack_pack_real_int8(x, d) \
do { \
	if(d < -(1<<5)) { \
		/* signed 8 */ \
		unsigned char buf[2] = {0xd0, TAKE8_8(d)}; \
		msgpack_pack_append_buffer(x, buf, 2); \
	} else { \
		/* fixnum */ \
		msgpack_pack_append_buffer(x, &TAKE8_8(d), 1); \
	} \
} while(0)

#define msgpack_pack_real_int16(x, d) \
do { \
	if(d < -(1<<5)) { \
		if(d < -(1<<7)) { \
			/* signed 16 */ \
			unsigned char buf[3]; \
			buf[0] = 0xd1; _msgpack_store16(&buf[1], (int16_t)d); \
			msgpack_pack_append_buffer(x, buf, 3); \
		} else { \
			/* signed 8 */ \
			unsigned char buf[2] = {0xd0, TAKE8_16(d)}; \
			msgpack_pack_append_buffer(x, buf, 2); \
		} \
	} else if(d < (1<<7)) { \
		/* fixnum */ \
		msgpack_pack_append_buffer(x, &TAKE8_16(d), 1); \
	} else { \
		if(d < (1<<8)) { \
			/* unsigned 8 */ \
			unsigned char buf[2] = {0xcc, TAKE8_16(d)}; \
			msgpack_pack_append_buffer(x, buf, 2); \
		} else { \
			/* unsigned 16 */ \
			unsigned char buf[3]; \
			buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
			msgpack_pack_append_buffer(x, buf, 3); \
		} \
	} \
} while(0)

#define msgpack_pack_real_int32(x, d) \
do { \
	if(d < -(1<<5)) { \
		if(d < -(1<<15)) { \
			/* signed 32 */ \
			unsigned char buf[5]; \
			buf[0] = 0xd2; _msgpack_store32(&buf[1], (int32_t)d); \
			msgpack_pack_append_buffer(x, buf, 5); \
		} else if(d < -(1<<7)) { \
			/* signed 16 */ \
			unsigned char buf[3]; \
			buf[0] = 0xd1; _msgpack_store16(&buf[1], (int16_t)d); \
			msgpack_pack_append_buffer(x, buf, 3); \
		} else { \
			/* signed 8 */ \
			unsigned char buf[2] = {0xd0, TAKE8_32(d)}; \
			msgpack_pack_append_buffer(x, buf, 2); \
		} \
	} else if(d < (1<<7)) { \
		/* fixnum */ \
		msgpack_pack_append_buffer(x, &TAKE8_32(d), 1); \
	} else { \
		if(d < (1<<8)) { \
			/* unsigned 8 */ \
			unsigned char buf[2] = {0xcc, TAKE8_32(d)}; \
			msgpack_pack_append_buffer(x, buf, 2); \
		} else if(d < (1<<16)) { \
			/* unsigned 16 */ \
			unsigned char buf[3]; \
			buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
			msgpack_pack_append_buffer(x, buf, 3); \
		} else { \
			/* unsigned 32 */ \
			unsigned char buf[5]; \
			buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
			msgpack_pack_append_buffer(x, buf, 5); \
		} \
	} \
} while(0)

#define msgpack_pack_real_int64(x, d) \
do { \
	if(d < -(1LL<<5)) { \
		if(d < -(1LL<<15)) { \
			if(d < -(1LL<<31)) { \
				/* signed 64 */ \
				unsigned char buf[9]; \
				buf[0] = 0xd3; _msgpack_store64(&buf[1], d); \
				msgpack_pack_append_buffer(x, buf, 9); \
			} else { \
				/* signed 32 */ \
				unsigned char buf[5]; \
				buf[0] = 0xd2; _msgpack_store32(&buf[1], (int32_t)d); \
				msgpack_pack_append_buffer(x, buf, 5); \
			} \
		} else { \
			if(d < -(1<<7)) { \
				/* signed 16 */ \
				unsigned char buf[3]; \
				buf[0] = 0xd1; _msgpack_store16(&buf[1], (int16_t)d); \
				msgpack_pack_append_buffer(x, buf, 3); \
			} else { \
				/* signed 8 */ \
				unsigned char buf[2] = {0xd0, TAKE8_64(d)}; \
				msgpack_pack_append_buffer(x, buf, 2); \
			} \
		} \
	} else if(d < (1<<7)) { \
		/* fixnum */ \
		msgpack_pack_append_buffer(x, &TAKE8_64(d), 1); \
	} else { \
		if(d < (1LL<<16)) { \
			if(d < (1<<8)) { \
				/* unsigned 8 */ \
				unsigned char buf[2] = {0xcc, TAKE8_64(d)}; \
				msgpack_pack_append_buffer(x, buf, 2); \
			} else { \
				/* unsigned 16 */ \
				unsigned char buf[3]; \
				buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
				msgpack_pack_append_buffer(x, buf, 3); \
			} \
		} else { \
			if(d < (1LL<<32)) { \
				/* unsigned 32 */ \
				unsigned char buf[5]; \
				buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
				msgpack_pack_append_buffer(x, buf, 5); \
			} else { \
				/* unsigned 64 */ \
				unsigned char buf[9]; \
				buf[0] = 0xcf; _msgpack_store64(&buf[1], d); \
				msgpack_pack_append_buffer(x, buf, 9); \
			} \
		} \
	} \
} while(0)


#ifdef msgpack_pack_inline_func_fixint

msgpack_pack_inline_func_fixint(_uint8)(msgpack_pack_user x, uint8_t d)
{
	unsigned char buf[2] = {0xcc, TAKE8_8(d)};
	msgpack_pack_append_buffer(x, buf, 2);
}

msgpack_pack_inline_func_fixint(_uint16)(msgpack_pack_user x, uint16_t d)
{
	unsigned char buf[3];
	buf[0] = 0xcd; _msgpack_store16(&buf[1], d);
	msgpack_pack_append_buffer(x, buf, 3);
}

msgpack_pack_inline_func_fixint(_uint32)(msgpack_pack_user x, uint32_t d)
{
	unsigned char buf[5];
	buf[0] = 0xce; _msgpack_store32(&buf[1], d);
	msgpack_pack_append_buffer(x, buf, 5);
}

msgpack_pack_inline_func_fixint(_uint64)(msgpack_pack_user x, uint64_t d)
{
	unsigned char buf[9];
	buf[0] = 0xcf; _msgpack_store64(&buf[1], d);
	msgpack_pack_append_buffer(x, buf, 9);
}

msgpack_pack_inline_func_fixint(_int8)(msgpack_pack_user x, int8_t d)
{
	unsigned char buf[2] = {0xd0, TAKE8_8(d)};
	msgpack_pack_append_buffer(x, buf, 2);
}

msgpack_pack_inline_func_fixint(_int16)(msgpack_pack_user x, int16_t d)
{
	unsigned char buf[3];
	buf[0] = 0xd1; _msgpack_store16(&buf[1], d);
	msgpack_pack_append_buffer(x, buf, 3);
}

msgpack_pack_inline_func_fixint(_int32)(msgpack_pack_user x, int32_t d)
{
	unsigned char buf[5];
	buf[0] = 0xd2; _msgpack_store32(&buf[1], d);
	msgpack_pack_append_buffer(x, buf, 5);
}

msgpack_pack_inline_func_fixint(_int64)(msgpack_pack_user x, int64_t d)
{
	unsigned char buf[9];
	buf[0] = 0xd3; _msgpack_store64(&buf[1], d);
	msgpack_pack_append_buffer(x, buf, 9);
}

#undef msgpack_pack_inline_func_fixint
#endif


msgpack_pack_inline_func(_uint8)(msgpack_pack_user x, uint8_t d)
{
	msgpack_pack_real_uint8(x, d);
}

msgpack_pack_inline_func(_uint16)(msgpack_pack_user x, uint16_t d)
{
	msgpack_pack_real_uint16(x, d);
}

msgpack_pack_inline_func(_uint32)(msgpack_pack_user x, uint32_t d)
{
	msgpack_pack_real_uint32(x, d);
}

msgpack_pack_inline_func(_uint64)(msgpack_pack_user x, uint64_t d)
{
	msgpack_pack_real_uint64(x, d);
}

msgpack_pack_inline_func(_int8)(msgpack_pack_user x, int8_t d)
{
	msgpack_pack_real_int8(x, d);
}

msgpack_pack_inline_func(_int16)(msgpack_pack_user x, int16_t d)
{
	msgpack_pack_real_int16(x, d);
}

msgpack_pack_inline_func(_int32)(msgpack_pack_user x, int32_t d)
{
	msgpack_pack_real_int32(x, d);
}

msgpack_pack_inline_func(_int64)(msgpack_pack_user x, int64_t d)
{
	msgpack_pack_real_int64(x, d);
}


#ifdef msgpack_pack_inline_func_cint

msgpack_pack_inline_func_cint(_short)(msgpack_pack_user x, short d)
{
#if defined(SIZEOF_SHORT)
#if SIZEOF_SHORT == 2
	msgpack_pack_real_int16(x, d);
#elif SIZEOF_SHORT == 4
	msgpack_pack_real_int32(x, d);
#else
	msgpack_pack_real_int64(x, d);
#endif

#elif defined(SHRT_MAX)
#if SHRT_MAX == 0x7fff
	msgpack_pack_real_int16(x, d);
#elif SHRT_MAX == 0x7fffffff
	msgpack_pack_real_int32(x, d);
#else
	msgpack_pack_real_int64(x, d);
#endif

#else
if(sizeof(short) == 2) {
	msgpack_pack_real_int16(x, d);
} else if(sizeof(short) == 4) {
	msgpack_pack_real_int32(x, d);
} else {
	msgpack_pack_real_int64(x, d);
}
#endif
}

msgpack_pack_inline_func_cint(_int)(msgpack_pack_user x, int d)
{
#if defined(SIZEOF_INT)
#if SIZEOF_INT == 2
	msgpack_pack_real_int16(x, d);
#elif SIZEOF_INT == 4
	msgpack_pack_real_int32(x, d);
#else
	msgpack_pack_real_int64(x, d);
#endif

#elif defined(INT_MAX)
#if INT_MAX == 0x7fff
	msgpack_pack_real_int16(x, d);
#elif INT_MAX == 0x7fffffff
	msgpack_pack_real_int32(x, d);
#else
	msgpack_pack_real_int64(x, d);
#endif

#else
if(sizeof(int) == 2) {
	msgpack_pack_real_int16(x, d);
} else if(sizeof(int) == 4) {
	msgpack_pack_real_int32(x, d);
} else {
	msgpack_pack_real_int64(x, d);
}
#endif
}

msgpack_pack_inline_func_cint(_long)(msgpack_pack_user x, long d)
{
#if defined(SIZEOF_LONG)
#if SIZEOF_LONG == 2
	msgpack_pack_real_int16(x, d);
#elif SIZEOF_LONG == 4
	msgpack_pack_real_int32(x, d);
#else
	msgpack_pack_real_int64(x, d);
#endif

#elif defined(LONG_MAX)
#if LONG_MAX == 0x7fffL
	msgpack_pack_real_int16(x, d);
#elif LONG_MAX == 0x7fffffffL
	msgpack_pack_real_int32(x, d);
#else
	msgpack_pack_real_int64(x, d);
#endif

#else
if(sizeof(long) == 2) {
	msgpack_pack_real_int16(x, d);
} else if(sizeof(long) == 4) {
	msgpack_pack_real_int32(x, d);
} else {
	msgpack_pack_real_int64(x, d);
}
#endif
}

msgpack_pack_inline_func_cint(_long_long)(msgpack_pack_user x, long long d)
{
#if defined(SIZEOF_LONG_LONG)
#if SIZEOF_LONG_LONG == 2
	msgpack_pack_real_int16(x, d);
#elif SIZEOF_LONG_LONG == 4
	msgpack_pack_real_int32(x, d);
#else
	msgpack_pack_real_int64(x, d);
#endif

#elif defined(LLONG_MAX)
#if LLONG_MAX == 0x7fffL
	msgpack_pack_real_int16(x, d);
#elif LLONG_MAX == 0x7fffffffL
	msgpack_pack_real_int32(x, d);
#else
	msgpack_pack_real_int64(x, d);
#endif

#else
if(sizeof(long long) == 2) {
	msgpack_pack_real_int16(x, d);
} else if(sizeof(long long) == 4) {
	msgpack_pack_real_int32(x, d);
} else {
	msgpack_pack_real_int64(x, d);
}
#endif
}

msgpack_pack_inline_func_cint(_unsigned_short)(msgpack_pack_user x, unsigned short d)
{
#if defined(SIZEOF_SHORT)
#if SIZEOF_SHORT == 2
	msgpack_pack_real_uint16(x, d);
#elif SIZEOF_SHORT == 4
	msgpack_pack_real_uint32(x, d);
#else
	msgpack_pack_real_uint64(x, d);
#endif

#elif defined(USHRT_MAX)
#if USHRT_MAX == 0xffffU
	msgpack_pack_real_uint16(x, d);
#elif USHRT_MAX == 0xffffffffU
	msgpack_pack_real_uint32(x, d);
#else
	msgpack_pack_real_uint64(x, d);
#endif

#else
if(sizeof(unsigned short) == 2) {
	msgpack_pack_real_uint16(x, d);
} else if(sizeof(unsigned short) == 4) {
	msgpack_pack_real_uint32(x, d);
} else {
	msgpack_pack_real_uint64(x, d);
}
#endif
}

msgpack_pack_inline_func_cint(_unsigned_int)(msgpack_pack_user x, unsigned int d)
{
#if defined(SIZEOF_INT)
#if SIZEOF_INT == 2
	msgpack_pack_real_uint16(x, d);
#elif SIZEOF_INT == 4
	msgpack_pack_real_uint32(x, d);
#else
	msgpack_pack_real_uint64(x, d);
#endif

#elif defined(UINT_MAX)
#if UINT_MAX == 0xffffU
	msgpack_pack_real_uint16(x, d);
#elif UINT_MAX == 0xffffffffU
	msgpack_pack_real_uint32(x, d);
#else
	msgpack_pack_real_uint64(x, d);
#endif

#else
if(sizeof(unsigned int) == 2) {
	msgpack_pack_real_uint16(x, d);
} else if(sizeof(unsigned int) == 4) {
	msgpack_pack_real_uint32(x, d);
} else {
	msgpack_pack_real_uint64(x, d);
}
#endif
}

msgpack_pack_inline_func_cint(_unsigned_long)(msgpack_pack_user x, unsigned long d)
{
#if defined(SIZEOF_LONG)
#if SIZEOF_LONG == 2
	msgpack_pack_real_uint16(x, d);
#elif SIZEOF_LONG == 4
	msgpack_pack_real_uint32(x, d);
#else
	msgpack_pack_real_uint64(x, d);
#endif

#elif defined(ULONG_MAX)
#if ULONG_MAX == 0xffffUL
	msgpack_pack_real_uint16(x, d);
#elif ULONG_MAX == 0xffffffffUL
	msgpack_pack_real_uint32(x, d);
#else
	msgpack_pack_real_uint64(x, d);
#endif

#else
if(sizeof(unsigned long) == 2) {
	msgpack_pack_real_uint16(x, d);
} else if(sizeof(unsigned long) == 4) {
	msgpack_pack_real_uint32(x, d);
} else {
	msgpack_pack_real_uint64(x, d);
}
#endif
}

msgpack_pack_inline_func_cint(_unsigned_long_long)(msgpack_pack_user x, unsigned long long d)
{
#if defined(SIZEOF_LONG_LONG)
#if SIZEOF_LONG_LONG == 2
	msgpack_pack_real_uint16(x, d);
#elif SIZEOF_LONG_LONG == 4
	msgpack_pack_real_uint32(x, d);
#else
	msgpack_pack_real_uint64(x, d);
#endif

#elif defined(ULLONG_MAX)
#if ULLONG_MAX == 0xffffUL
	msgpack_pack_real_uint16(x, d);
#elif ULLONG_MAX == 0xffffffffUL
	msgpack_pack_real_uint32(x, d);
#else
	msgpack_pack_real_uint64(x, d);
#endif

#else
if(sizeof(unsigned long long) == 2) {
	msgpack_pack_real_uint16(x, d);
} else if(sizeof(unsigned long long) == 4) {
	msgpack_pack_real_uint32(x, d);
} else {
	msgpack_pack_real_uint64(x, d);
}
#endif
}

#undef msgpack_pack_inline_func_cint
#endif



/*
 * Float
 */

msgpack_pack_inline_func(_float)(msgpack_pack_user x, float d)
{
	union { float f; uint32_t i; } mem;
	mem.f = d;
	unsigned char buf[5];
	buf[0] = 0xca; _msgpack_store32(&buf[1], mem.i);
	msgpack_pack_append_buffer(x, buf, 5);
}

msgpack_pack_inline_func(_double)(msgpack_pack_user x, double d)
{
	union { double f; uint64_t i; } mem;
	mem.f = d;
	unsigned char buf[9];
	buf[0] = 0xcb; _msgpack_store64(&buf[1], mem.i);
	msgpack_pack_append_buffer(x, buf, 9);
}


/*
 * Nil
 */

msgpack_pack_inline_func(_nil)(msgpack_pack_user x)
{
	static const unsigned char d = 0xc0;
	msgpack_pack_append_buffer(x, &d, 1);
}


/*
 * Boolean
 */

msgpack_pack_inline_func(_true)(msgpack_pack_user x)
{
	static const unsigned char d = 0xc3;
	msgpack_pack_append_buffer(x, &d, 1);
}

msgpack_pack_inline_func(_false)(msgpack_pack_user x)
{
	static const unsigned char d = 0xc2;
	msgpack_pack_append_buffer(x, &d, 1);
}


/*
 * Array
 */

msgpack_pack_inline_func(_array)(msgpack_pack_user x, unsigned int n)
{
	if(n < 16) {
		unsigned char d = 0x90 | n;
		msgpack_pack_append_buffer(x, &d, 1);
	} else if(n < 65536) {
		unsigned char buf[3];
		buf[0] = 0xdc; _msgpack_store16(&buf[1], (uint16_t)n);
		msgpack_pack_append_buffer(x, buf, 3);
	} else {
		unsigned char buf[5];
		buf[0] = 0xdd; _msgpack_store32(&buf[1], (uint32_t)n);
		msgpack_pack_append_buffer(x, buf, 5);
	}
}


/*
 * Map
 */

msgpack_pack_inline_func(_map)(msgpack_pack_user x, unsigned int n)
{
	if(n < 16) {
		unsigned char d = 0x80 | n;
		msgpack_pack_append_buffer(x, &TAKE8_8(d), 1);
	} else if(n < 65536) {
		unsigned char buf[3];
		buf[0] = 0xde; _msgpack_store16(&buf[1], (uint16_t)n);
		msgpack_pack_append_buffer(x, buf, 3);
	} else {
		unsigned char buf[5];
		buf[0] = 0xdf; _msgpack_store32(&buf[1], (uint32_t)n);
		msgpack_pack_append_buffer(x, buf, 5);
	}
}


/*
 * Raw
 */

msgpack_pack_inline_func(_raw)(msgpack_pack_user x, size_t l)
{
	if(l < 32) {
		unsigned char d = 0xa0 | (uint8_t)l;
		msgpack_pack_append_buffer(x, &TAKE8_8(d), 1);
	} else if(l < 65536) {
		unsigned char buf[3];
		buf[0] = 0xda; _msgpack_store16(&buf[1], (uint16_t)l);
		msgpack_pack_append_buffer(x, buf, 3);
	} else {
		unsigned char buf[5];
		buf[0] = 0xdb; _msgpack_store32(&buf[1], (uint32_t)l);
		msgpack_pack_append_buffer(x, buf, 5);
	}
}

msgpack_pack_inline_func(_raw_body)(msgpack_pack_user x, const void* b, size_t l)
{
	msgpack_pack_append_buffer(x, (const unsigned char*)b, l);
}

#undef msgpack_pack_inline_func
#undef msgpack_pack_user
#undef msgpack_pack_append_buffer

#undef TAKE8_8
#undef TAKE8_16
#undef TAKE8_32
#undef TAKE8_64

#undef msgpack_pack_real_uint8
#undef msgpack_pack_real_uint16
#undef msgpack_pack_real_uint32
#undef msgpack_pack_real_uint64
#undef msgpack_pack_real_int8
#undef msgpack_pack_real_int16
#undef msgpack_pack_real_int32
#undef msgpack_pack_real_int64

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * MessagePack system dependencies
 *
 * Copyright (C) 2008-2010 FURUHASHI Sadayuki
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
#ifndef MSGPACK_SYSDEP_H__
#define MSGPACK_SYSDEP_H__

#include <stdlib.h>
#include <stddef.h>
#if defined(_MSC_VER) && _MSC_VER < 1600
typedef __int8 int8_t;
typedef unsigned __int8 uint8_t;
typedef __int16 int16_t;
typedef unsigned __int16 uint16_t;
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#elif defined(_MSC_VER)  // && _MSC_VER >= 1600
#include <stdint.h>
#else
#include <stdint.h>
#include <stdbool.h>
#endif

#ifdef _WIN32
#define _msgpack_atomic_counter_header <windows.h>
typedef long _msgpack_atomic_counter_t;
#define _msgpack_sync_decr_and_fetch(ptr) InterlockedDecrement(ptr)
#define _msgpack_sync_incr_and_fetch(ptr) InterlockedIncrement(ptr)
#elif defined(__GNUC__) && ((__GNUC__*10 + __GNUC_MINOR__) < 41)
#define _msgpack_atomic_counter_header "gcc_atomic.h"
#else
typedef unsigned int _msgpack_atomic_counter_t;
#define _msgpack_sync_decr_and_fetch(ptr) __sync_sub_and_fetch(ptr, 1)
#define _msgpack_sync_incr_and_fetch(ptr) __sync_add_and_fetch(ptr, 1)
#endif

#ifdef _WIN32

#ifdef __cplusplus
/* numeric_limits<T>::min,max */
#ifdef max
#undef max
#endif
#ifdef min
#undef min
#endif
#endif

#else
#include <arpa/inet.h>  /* __BYTE_ORDER */
#endif

#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
#if __BYTE_ORDER == __LITTLE_ENDIAN
#define __LITTLE_ENDIAN__
#elif __BYTE_ORDER == __BIG_ENDIAN
#define __BIG_ENDIAN__
#elif _WIN32
#define __LITTLE_ENDIAN__
#endif
#endif


#ifdef __LITTLE_ENDIAN__

#ifdef _WIN32
#  if defined(ntohs)
#    define _msgpack_be16(x) ntohs(x)
#  elif defined(_byteswap_ushort) || (defined(_MSC_VER) && _MSC_VER >= 1400)
#    define _msgpack_be16(x) ((uint16_t)_byteswap_ushort((unsigned short)x))
#  else
#    define _msgpack_be16(x) ( \
        ((((uint16_t)x) <<  8) ) | \
        ((((uint16_t)x) >>  8) ) )
#  endif
#else
#  define _msgpack_be16(x) ntohs(x)
#endif

#ifdef _WIN32
#  if defined(ntohl)
#    define _msgpack_be32(x) ntohl(x)
#  elif defined(_byteswap_ulong) || (defined(_MSC_VER) && _MSC_VER >= 1400)
#    define _msgpack_be32(x) ((uint32_t)_byteswap_ulong((unsigned long)x))
#  else
#    define _msgpack_be32(x) \
        ( ((((uint32_t)x) << 24)               ) | \
          ((((uint32_t)x) <<  8) & 0x00ff0000U ) | \
          ((((uint32_t)x) >>  8) & 0x0000ff00U ) | \
          ((((uint32_t)x) >> 24)               ) )
#  endif
#else
#  define _msgpack_be32(x) ntohl(x)
#endif

#if defined(_byteswap_uint64) || (defined(_MSC_VER) && _MSC_VER >= 1400)
#  define _msgpack_be64(x) (_byteswap_uint64(x))
#elif defined(bswap_64)
#  define _msgpack_be64(x) bswap_64(x)
#elif defined(__DARWIN_OSSwapInt64)
#  define _msgpack_be64(x) __DARWIN_OSSwapInt64(x)
#else
#define _msgpack_be64(x) \
    ( ((((uint64_t)x) << 56)                         ) | \
      ((((uint64_t)x) << 40) & 0x00ff000000000000ULL ) | \
      ((((uint64_t)x) << 24) & 0x0000ff0000000000ULL ) | \
      ((((uint64_t)x) <<  8) & 0x000000ff00000000ULL ) | \
      ((((uint64_t)x) >>  8) & 0x00000000ff000000ULL ) | \
      ((((uint64_t)x) >> 24) & 0x0000000000ff0000ULL ) | \
      ((((uint64_t)x) >> 40) & 0x000000000000ff00ULL ) | \
      ((((uint64_t)x) >> 56)                         ) )
#endif

#define _msgpack_load16(cast, from) ((cast)( \
        (((uint16_t)((uint8_t*)(from))[0]) << 8) | \
        (((uint16_t)((uint8_t*)(from))[1])     ) ))

#define _msgpack_load32(cast, from) ((cast)( \
        (((uint32_t)((uint8_t*)(from))[0]) << 24) | \
        (((uint32_t)((uint8_t*)(from))[1]) << 16) | \
        (((uint32_t)((uint8_t*)(from))[2]) <<  8) | \
        (((uint32_t)((uint8_t*)(from))[3])      ) ))

#define _msgpack_load64(cast, from) ((cast)( \
        (((uint64_t)((uint8_t*)(from))[0]) << 56) | \
        (((uint64_t)((uint8_t*)(from))[1]) << 48) | \
        (((uint64_t)((uint8_t*)(from))[2]) << 40) | \
        (((uint64_t)((uint8_t*)(from))[3]) << 32) | \
        (((uint64_t)((uint8_t*)(from))[4]) << 24) | \
        (((uint64_t)((uint8_t*)(from))[5]) << 16) | \
        (((uint64_t)((uint8_t*)(from))[6]) << 8)  | \
        (((uint64_t)((uint8_t*)(from))[7])     )  ))

#else

#define _msgpack_be16(x) (x)
#define _msgpack_be32(x) (x)
#define _msgpack_be64(x) (x)

#define _msgpack_load16(cast, from) ((cast)( \
        (((uint16_t)((uint8_t*)from)[1]) << 8) | \
        (((uint16_t)((uint8_t*)from)[0])     ) ))

#define _msgpack_load32(cast, from) ((cast)( \
        (((uint32_t)((uint8_t*)from)[3]) << 24) | \
        (((uint32_t)((uint8_t*)from)[2]) << 16) | \
        (((uint32_t)((uint8_t*)from)[1]) <<  8) | \
        (((uint32_t)((uint8_t*)from)[0])      ) ))

#define _msgpack_load64(cast, from) ((cast)( \
        (((uint64_t)((uint8_t*)from)[7]) << 56) | \
        (((uint64_t)((uint8_t*)from)[6]) << 48) | \
        (((uint64_t)((uint8_t*)from)[5]) << 40) | \
        (((uint64_t)((uint8_t*)from)[4]) << 32) | \
        (((uint64_t)((uint8_t*)from)[3]) << 24) | \
        (((uint64_t)((uint8_t*)from)[2]) << 16) | \
        (((uint64_t)((uint8_t*)from)[1]) << 8)  | \
        (((uint64_t)((uint8_t*)from)[0])     )  ))
#endif


#define _msgpack_store16(to, num) \
    do { uint16_t val = _msgpack_be16(num); memcpy(to, &val, 2); } while(0)
#define _msgpack_store32(to, num) \
    do { uint32_t val = _msgpack_be32(num); memcpy(to, &val, 4); } while(0)
#define _msgpack_store64(to, num) \
    do { uint64_t val = _msgpack_be64(num); memcpy(to, &val, 8); } while(0)

/*
#define _msgpack_load16(cast, from) \
    ({ cast val; memcpy(&val, (char*)from, 2); _msgpack_be16(val); })
#define _msgpack_load32(cast, from) \
    ({ cast val; memcpy(&val, (char*)from, 4); _msgpack_be32(val); })
#define _msgpack_load64(cast, from) \
    ({ cast val; memcpy(&val, (char*)from, 8); _msgpack_be64(val); })
*/


#endif /* msgpack/sysdep.h */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * MessagePack unpacking routine template
 *
 * Copyright (C) 2008-2010 FURUHASHI Sadayuki
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
#ifndef MSGPACK_UNPACK_DEFINE_H__
#define MSGPACK_UNPACK_DEFINE_H__

#include "msgpack/sysdep.h"
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif


#ifndef MSGPACK_EMBED_STACK_SIZE
#define MSGPACK_EMBED_STACK_SIZE 32
#endif


typedef enum {
	CS_HEADER            = 0x00,  // nil

	//CS_                = 0x01,
	//CS_                = 0x02,  // false
	//CS_                = 0x03,  // true

	//CS_                = 0x04,
	//CS_                = 0x05,
	//CS_                = 0x06,
	//CS_                = 0x07,

	//CS_                = 0x08,
	//CS_                = 0x09,
	CS_FLOAT             = 0x0a,
	CS_DOUBLE            = 0x0b,
	CS_UINT_8            = 0x0c,
	CS_UINT_16           = 0x0d,
	CS_UINT_32           = 0x0e,
	CS_UINT_64           = 0x0f,
	CS_INT_8             = 0x10,
	CS_INT_16            = 0x11,
	CS_INT_32            = 0x12,
	CS_INT_64            = 0x13,

	//CS_                = 0x14,
	//CS_                = 0x15,
	//CS_BIG_INT_16        = 0x16,
	//CS_BIG_INT_32        = 0x17,
	//CS_BIG_FLOAT_16      = 0x18,
	//CS_BIG_FLOAT_32      = 0x19,
	CS_RAW_16            = 0x1a,
	CS_RAW_32            = 0x1b,
	CS_ARRAY_16          = 0x1c,
	CS_ARRAY_32          = 0x1d,
	CS_MAP_16            = 0x1e,
	CS_MAP_32            = 0x1f,

	//ACS_BIG_INT_VALUE,
	//ACS_BIG_FLOAT_VALUE,
	ACS_RAW_VALUE,
} msgpack_unpack_state;


typedef enum {
	CT_ARRAY_ITEM,
	CT_MAP_KEY,
	CT_MAP_VALUE,
} msgpack_container_type;


#ifdef __cplusplus
}
#endif

#endif /* msgpack/unpack_define.h */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * MessagePack unpacking routine template
 *
 * Copyright (C) 2008-2010 FURUHASHI Sadayuki
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distr